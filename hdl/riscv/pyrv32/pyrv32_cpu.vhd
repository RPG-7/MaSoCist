-- File: pyrv32_cpu.vhd
-- Generated by MyHDL 0.9dev
-- Date: Mon Oct 21 14:06:17 2019


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_09.all;

entity pyrv32_cpu is
    port (
        clk: in std_logic;
        reset: in std_logic;
        exception_override: in std_logic;
        exception_irq: in std_logic;
        exception_evaddr: in unsigned(14 downto 0);
        exception_illegal: out std_logic;
        tap_reset: in std_logic;
        tap_emumask: in std_logic;
        tap_exstat: out unsigned(7 downto 0);
        tap_idata: in unsigned(31 downto 0);
        tap_addr: in unsigned(11 downto 0);
        tap_emuexec: in std_logic;
        tap_odata: out unsigned(31 downto 0);
        tap_emuir: in unsigned(31 downto 0);
        tap_emuack: out std_logic;
        tap_emurdy: out std_logic;
        tap_curpc: out unsigned(31 downto 0);
        tap_emureq: in std_logic;
        dmem_we: out std_logic;
        dmem_busy: in std_logic;
        dmem_addr: out unsigned(19 downto 0);
        dmem_re: out std_logic;
        dmem_ready: in std_logic;
        dmem_delay: out std_logic;
        dmem_wsize: out unsigned(1 downto 0);
        dmem_wdata: out unsigned(31 downto 0);
        dmem_rdata: in unsigned(31 downto 0);
        imem_write: out std_logic;
        imem_idata: in unsigned(31 downto 0);
        imem_read: out std_logic;
        imem_daddr: out unsigned(19 downto 0);
        imem_wdata: out unsigned(31 downto 0);
        imem_rdata: in unsigned(31 downto 0);
        imem_iaddr: out unsigned(19 downto 0);
        imem_ire: out std_logic
    );
end entity pyrv32_cpu;
-- The pyrv32 - a simplified 32 bit RiscV
-- 
-- This is a RISC-V RV32I compatible derivative of the configurable
-- PyPS architecture (written in Python/MyHDL)
-- 
-- (c) 2014-2019, info@section5.ch
-- 
--     CHANGES:
--  *  2016       MIPS dropped
--  *  2019       added support for RV32I/C instruction set
-- 
-- This architecture is not completely verified or considered frozen.
-- However, it has passed all (except fence_i) rv32ui ISA tests
-- from the riscv-tests suite https://github.com/riscv/riscv-tests
-- (as of October 2019)
-- 
-- You may use and evaluate it under the MaSoCist license:
--   https://github.com/hackfin/masocist
-- 
-- Configuration notes:
-- 
-- - When CONFIG_RV32_CSR not enabled, debug ICE is limited and must operate
--   via memory mapped registers to communicate with external debug logic.
-- - IRQs are treated the same as exceptions, unless CONFIG_SCACHE option
--   is enabled
-- - When a CSR is implemented, exception support and event vectoring will go
--   through this CSR. By default, we don't use the CSR logic and use
--   the ZPUng SIC (CONFIG_SIC=True).
-- 
--   NOTE! The pyrv32 does not support nested interrupts in hardware. Interrupt
--   handlers must explicitely allow nesting by unlocking the IRQ logic (evt_override)
-- 
-- ############################################
-- ##########     CONFIGURATION     ###########
-- ############################################
-- CONFIG_ALLOW_IMEM_ACCESS = True
-- CONFIG_DEBUG_ICE = True
-- CONFIG_RISCV_PYRV32 = True
-- CONFIG_PYRV32_VARIANT = 1
-- CONFIG_FOUR_STAGE_PIPELINE = True
-- CONFIG_RV32_CSR = True
-- CONFIG_SIC = True
-- CONFIG_RISCV_ARCH = True
-- CONFIG_ALLOW_IMEM_WRITE = True
-- CONFIG_EARLY_BRANCH_DETECTION = True
-- ############################################
-- >  DISABLED:
-- ############################################
--     CONFIG_READ_DELAY
--     CONFIG_BRANCH_PREDICTION_DP
--     CONFIG_RELAXED_LSB
--     CONFIG_SUPERVISOR_INSTRUCTIONS
--     CONFIG_COMPRESSED_INSTRUCTIONS
--     CONFIG_FLIX_INSTRUCTIONS
--     CONFIG_LATE_MEMBUSY
--     CONFIG_SCACHE
--     CONFIG_COTTONPICKEN
-- ############################################

architecture MyHDL of pyrv32_cpu is


constant FN_CSRRW: integer := 1;
constant PIPE_RESET_BRANCH: integer := 1;
constant FN_CSRRS: integer := 2;
constant CSR_DEPC: integer := 1953;
constant FN_BGE: integer := 5;
constant CONFIG_BRAM_ADDR_WIDTH: integer := 2**4-1;
constant FN_BEQ: integer := 0;
constant FN_CSRRC: integer := 3;
constant PIPELEN: integer := 4;
constant FN_W: integer := 2;
constant FN_ADD_SUB: integer := 0;
constant CSR_MTVEC: integer := 773;
subtype SLICE_RS1 is integer range 20-1 downto 15;
constant RV32_BRANCH: integer := 99;
constant LDST_DWORD: integer := 2;
subtype SLICE_RS2 is integer range 25-1 downto 20;
constant FN_BLTU: integer := 6;
constant RV32_LUI: integer := 55;
constant CSR_MIE: integer := 772;
constant RV32_JALR: integer := 103;
constant FN_B: integer := 0;
constant ADDR_SZ: integer := 20;
constant FN_SLTU: integer := 3;
constant RV32_SYSTEM: integer := 115;
constant FN_H: integer := 1;
constant FN_SRA_SRL: integer := 5;
constant FN_AND: integer := 7;
constant CSR_MEPC: integer := 833;
constant RV32_STORE: integer := 35;
subtype OPCODE is integer range 7-1 downto 0;
constant INSTRUCTION_SIZE_BYTES: integer := 4;
constant FN_BNE: integer := 1;
constant CSR_MCAUSE: integer := 834;
constant FN_XOR: integer := 4;
constant RV32_AUIPC: integer := 23;
constant FN_BLT: integer := 4;
constant FN_BGEU: integer := 7;
constant FN12_WFI: integer := 261;
constant LDST_WORD: integer := 1;
constant FN_SLL: integer := 1;
constant RV32_OP_IMM: integer := 19;
constant CONFIG_DATAMEM_OFFSET_BIT: integer := 2**4;
constant RV32_OP: integer := 51;
constant RV32_JAL: integer := 111;
constant CSR_SCRATCH0: integer := 1954;
constant FN_PRIV: integer := 0;
constant PC_ADDRESS_LSB: integer := 0;
subtype FUNCT3 is integer range 15-1 downto 12;
constant CONFIG_CSR_MMR: integer := 0;
constant CSR_MISA: integer := 769;
constant FN_BU: integer := 4;
constant FN12_DRET: integer := 1970;
constant FN_SLT: integer := 2;
constant FN_OR: integer := 6;
constant RV32_LOAD: integer := 3;
constant CSR_MSTATUS: integer := 768;
constant FN12_MRET: integer := 770;
constant FN_HU: integer := 5;
constant LDST_BYTE: integer := 0;
subtype FUNCT12 is integer range 32-1 downto 20;
subtype SLICE_RD is integer range 12-1 downto 7;
constant CONFIG_MMR_ADDR_BIT: integer := 18;
constant x: integer := 2**5;
constant MOD_ARITH: integer := 30;
constant FN12_EBREAK: integer := 1;


type t_enum_dbg_state_5 is (
    S_RUN,
    S_RESUME,
    S_EMUACK,
    S_EMULATION,
    S_EMUEXEC
);
type t_enum_t_aluop_4 is (
    A_NOP,
    A_ADD,
    A_SUB,
    A_SRL,
    A_SRA,
    A_SLL,
    A_SLT,
    A_SLTU,
    A_XOR,
    A_OR,
    A_AND
);
type t_enum_t_itype_6 is (
    TYPE_NONE,
    TYPE_R,
    TYPE_I,
    TYPE_B,
    TYPE_S,
    TYPE_U,
    TYPE_J
);
type t_enum_t_lmode_2 is (
    LB,
    LH,
    LW,
    LBU,
    LHU
);
type t_enum_t_mode_3 is (
    NOP,
    JMP,
    COND_BRANCH,
    LOAD,
    STORE,
    IMMEDIATE,
    ALU,
    CONTROL,
    EXTEND,
    ILLEGAL,
    xRET,
    RETE,
    SWTRAP,
    IDLE,
    CP_XCH,
    CP_SET,
    CP_CLR
);
type t_enum_t_state_1 is (
    S_RESET,
    S_IDLE,
    S_EXEC,
    S_DELAY,
    S_EVT,
    S_EVT_DELAY,
    S_IRQ,
    S_IRQ_DELAY,
    S_HOLD,
    S_WAIT,
    S_HOLD_DELAY,
    S_RESUME,
    S_BRANCH_SYNC,
    S_BRANCH_DELAY,
    S_EXC
);

signal evt_brk: std_logic;
signal evt_membusy: std_logic;
signal regd_we: std_logic;
signal action_delay: std_logic;
signal imm: unsigned(31 downto 0);
signal regd_addr: unsigned(4 downto 0);
signal evt_reti: std_logic;
signal haz_s2bypass: std_logic;
signal curpc: unsigned(14 downto 0);
signal evt_hold: std_logic;
signal pipe_clr: std_logic;
signal de_en: std_logic;
signal evt_emuack: std_logic;
signal s2_haz: std_logic;
signal lhold: std_logic;
signal ex_en: std_logic;
signal action_reg_we: std_logic;
signal evt_reset: std_logic;
signal ibranch: std_logic;
signal newpc: unsigned(14 downto 0);
signal haz_load_collision: std_logic;
signal irqack: std_logic;
signal reg_s1: unsigned(4 downto 0);
signal evt_dbgbreak: std_logic;
signal evt_saveret: std_logic;
signal action_rete: std_logic;
signal evt_irq: std_logic;
signal state: t_enum_t_state_1;
signal evt_stall: std_logic;
signal did_stall: std_logic;
signal mode: t_enum_t_mode_3;
signal haz_s2bypass_delayed: std_logic;
signal evt_override: std_logic;
signal rdata_d: unsigned(31 downto 0);
signal evt_rete: std_logic;
signal evt_busy: std_logic;
signal evt_emuexec: std_logic;
signal reg_s2: unsigned(4 downto 0);
signal reg_d: unsigned(4 downto 0);
signal haz_s1bypass_delayed: std_logic;
signal evt_exception: std_logic;
signal action_preload: std_logic;
signal evt_dbg_wr: std_logic;
signal haz_s1bypass: std_logic;
signal irqlatch0: std_logic;
signal func: unsigned(2 downto 0);
signal evt_vector: unsigned(14 downto 0);
signal evt_idle: std_logic;
signal depc: unsigned(14 downto 0);
signal action_saveret: std_logic;
signal expc: unsigned(14 downto 0);
signal irqprio: std_logic;
signal pipe_en: std_logic;
signal regd_data: unsigned(31 downto 0);
signal action_upie: std_logic;
signal maybe_bypass_s1: std_logic;
signal action_dbg_wr: std_logic;
signal fe_en: std_logic;
signal trigger_hold: std_logic;
signal branch: std_logic;
signal action_wreg: std_logic;
signal evt_cpustat: unsigned(7 downto 0);
signal action_branch: std_logic;
signal evt_data_valid: std_logic;
signal insn: unsigned(31 downto 0);
signal evt_emumask: std_logic;
signal s1_haz: std_logic;
signal haz_access_future: std_logic;
signal pipe_valid: unsigned(3 downto 0);
signal lwait: std_logic;
signal sh: unsigned(4 downto 0);
signal action_emuexec: std_logic;
signal maybe_debug_swbreak: std_logic;
signal maybe_debug_busy: std_logic;
signal maybe_debug_state: t_enum_dbg_state_5;
signal maybe_debug_emumask: std_logic;
signal s3_execute_mux_sh: unsigned(4 downto 0);
signal s3_execute_regs1_buf: unsigned(31 downto 0);
signal s3_execute_mem_store_data: unsigned(31 downto 0);
signal s3_execute_mux_b: unsigned(31 downto 0);
signal s3_execute_action_immediate: std_logic;
signal s3_execute_result: unsigned(31 downto 0);
signal s3_execute_mem_addr: unsigned(31 downto 0);
signal s3_execute_reg_s2: unsigned(31 downto 0);
signal s3_execute_indirect: unsigned(31 downto 0);
signal s3_execute_reg_s1: unsigned(31 downto 0);
signal s3_execute_rs2: unsigned(31 downto 0);
signal s3_execute_action_swbrk: std_logic;
signal s3_execute_action_load: std_logic;
signal s3_execute_reg_we_d: std_logic;
signal s3_execute_reg_we: std_logic;
signal s3_execute_rs1: unsigned(31 downto 0);
signal s3_execute_will_branch: std_logic;
signal s3_execute_regd_buf: unsigned(31 downto 0);
signal s3_execute_s1bypass_d: std_logic;
signal s3_execute_did_stall: std_logic;
signal s3_execute_s1bypass: std_logic;
signal s3_execute_csrreg_depc: unsigned(31 downto 0);
signal s3_execute_branch: std_logic;
signal s3_execute_alu_en: std_logic;
signal s3_execute_reg_out: unsigned(31 downto 0);
signal s3_execute_s2bypass: std_logic;
signal s3_execute_csrreg_mepc: unsigned(31 downto 0);
signal s3_execute_mux_a: unsigned(31 downto 0);
signal s3_execute_csr_xs: std_logic;
signal s3_execute_mem_load_data: unsigned(31 downto 0);
signal s3_execute_jump_target: unsigned(31 downto 0);
signal s3_execute_mepc: unsigned(14 downto 0);
signal s3_execute_s2bypass_d: std_logic;
signal s3_execute_action_srcpc: std_logic;
signal s3_execute_regs2_buf: unsigned(31 downto 0);
signal s3_execute_action_store: std_logic;
signal s3_execute_reg_in: unsigned(31 downto 0);
signal s3_execute_did_load: std_logic;
signal s3_execute_inst_csr_csr_we: std_logic;
signal s3_execute_inst_csr_illegal_csr: std_logic;
signal s3_execute_inst_csr_csr_addr: unsigned(11 downto 0);
signal s3_execute_inst_csr_csrreg_mcause: unsigned(31 downto 0);
signal s3_execute_inst_csr_csrreg_mstatus: unsigned(31 downto 0);
signal s3_execute_inst_csr_csrreg_mie: unsigned(31 downto 0);
signal s3_execute_inst_csr_csrreg_dscratch0: unsigned(31 downto 0);
signal s3_execute_inst_csr_csrreg_misa: unsigned(31 downto 0);
signal s3_execute_inst_csr_reg: unsigned(31 downto 0);
signal s3_execute_inst_csr_csrreg_mtvec: unsigned(31 downto 0);
signal s3_execute_inst_csr_data: unsigned(31 downto 0);
signal s3_execute_inst_csr_csr_re: std_logic;
signal s3_execute_inst_alu_alu_mode: t_enum_t_aluop_4;
signal s2_s4_memio_mode_d: t_enum_t_lmode_2;
signal s2_s4_memio_was_imem: std_logic;
signal s2_s4_memio_data_mux: unsigned(31 downto 0);
signal s2_s4_memio_is_imem: std_logic;
signal s2_s4_memio_dmem_busy_d: std_logic;
signal s2_s4_memio_act_lmode: t_enum_t_lmode_2;
signal s2_decode_de_action_aop: t_enum_t_aluop_4;
signal s2_decode_de_action_srcpc: std_logic;
signal s2_decode_de_action_immediate: std_logic;
signal s2_decode_de_action_lmode: t_enum_t_lmode_2;
signal s2_decode_pc_mode: t_enum_t_mode_3;
signal s2_decode_pc_func: unsigned(5 downto 0);
signal s2_decode_de_action_swbrk: std_logic;
signal s2_decode_de_action_wreg: std_logic;
signal s2_decode_pc_imm: unsigned(31 downto 0);
signal s2_decode_inst_decoder_imm31: std_logic;
signal s2_decode_inst_decoder_immtype: t_enum_t_itype_6;
signal s2_decode_inst_decoder_imm_extend_21: unsigned(20 downto 0);
signal s1_fetch_nextpc: unsigned(31 downto 0);
signal s1_fetch_pc: unsigned(31 downto 0);
type t_array_was_membusy is array(0 to 2-1) of std_logic;
signal was_membusy: t_array_was_membusy;
type t_array_was_delay is array(0 to 2-1) of std_logic;
signal was_delay: t_array_was_delay;
type t_array_regd_d is array(0 to 2-1) of unsigned(4 downto 0);
signal regd_d: t_array_regd_d;
type t_array_registers_regt is array(0 to 31-1) of unsigned(31 downto 0);
signal registers_regt: t_array_registers_regt;
type t_array_registers_regs is array(0 to 31-1) of unsigned(31 downto 0);
signal registers_regs: t_array_registers_regs;

function MYHDL45_UNDEFINED(
    x: in natural
    ) return unsigned is
begin
    return unsigned'("00000000000000000000000000000000");
end function MYHDL45_UNDEFINED;

begin


s2_decode_inst_decoder_imm_extend_21(20) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(19) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(18) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(17) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(16) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(15) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(14) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(13) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(12) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(11) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(10) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(9) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(8) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(7) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(6) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(5) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(4) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(3) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(2) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(1) <= s2_decode_inst_decoder_imm31;
s2_decode_inst_decoder_imm_extend_21(0) <= s2_decode_inst_decoder_imm31;

-- * Hazard 3: when in delayed writeback (S_DELAY state)
--   and a result is needed *two* cycles later:
--   > Forward value
-- 
-- This is a nasty one. PyPS throws an exception when writing reg 0,
-- Risc-V does not. So we don't have a hazard when we were just
-- dummy-writing to 0.
PYRV32_CPU_HAZ_DELAYED_WB: process (state, regd_d(1), reg_s1, reg_s2, did_stall) is
begin
    haz_s1bypass_delayed <= '0';
    haz_s2bypass_delayed <= '0';
    if ((state = S_DELAY) and (did_stall = '0') and (regd_d(1) /= 0)) then
        if (regd_d(1) = reg_s1) then
            haz_s1bypass_delayed <= '1';
        end if;
        if (regd_d(1) = reg_s2) then
            haz_s2bypass_delayed <= '1';
        end if;
    end if;
end process PYRV32_CPU_HAZ_DELAYED_WB;


PYRV32_CPU_REGISTERS_WORK: process (clk) is
begin
    if rising_edge(clk) then
        if (regd_we = '1') then
            if (regd_addr /= 0) then
                
                registers_regs(to_integer(regd_addr - 1)) <= regd_data;
                registers_regt(to_integer(regd_addr - 1)) <= regd_data;
            else
                
            end if;
        end if;
        if (de_en = '1') then
            if (reg_s1 = 0) then
                s3_execute_reg_s1 <= to_unsigned(0, 32);
            elsif ((reg_s1 = regd_addr) and (regd_we = '1')) then
                s3_execute_reg_s1 <= regd_data;
            else
                s3_execute_reg_s1 <= registers_regs(to_integer(reg_s1 - 1));
            end if;
            if (reg_s2 = 0) then
                s3_execute_reg_s2 <= to_unsigned(0, 32);
            elsif ((reg_s2 = regd_addr) and (regd_we = '1')) then
                s3_execute_reg_s2 <= regd_data;
            else
                s3_execute_reg_s2 <= registers_regs(to_integer(reg_s2 - 1));
            end if;
        end if;
    end if;
end process PYRV32_CPU_REGISTERS_WORK;


PYRV32_CPU_HAZ_LOAD_COLL: process (lwait, action_preload, action_delay, evt_membusy) is
begin
    if ((bool(action_preload) and (not bool(evt_membusy))) and bool(lwait) and bool(action_delay)) then
        haz_load_collision <= '1';
    else
        haz_load_collision <= '0';
    end if;
end process PYRV32_CPU_HAZ_LOAD_COLL;


PYRV32_CPU_HANDLE_MEMORY_DELAY_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        lwait <= stdl(bool(action_preload) and bool(evt_membusy));
        did_stall <= evt_stall;
        if (lhold = '0') then
            if (haz_load_collision = '1') then
                lhold <= '1';
            end if;
        else
            if (action_preload = '0') then
                lhold <= '0';
            end if;
        end if;
    end if;
end process PYRV32_CPU_HANDLE_MEMORY_DELAY_LOGIC;

-- Complex state machine using DELAY/shortcut pipeline implementation
-- Handles CPU state and program flow.
-- TODO: Simplify, use separate delay state.
PYRV32_CPU_STATE_WORKER: process (clk) is
begin
    if rising_edge(clk) then
        action_emuexec <= evt_emuexec;
        evt_saveret <= '0';
        case state is
            when S_RESET =>
                state <= S_EXEC;
            when S_EXEC =>
                if (trigger_hold = '1') then
                    if bool(evt_membusy) then
                        state <= S_WAIT;
                    elsif (not bool(evt_busy)) then
                        state <= S_HOLD;
                    end if;
                elsif (action_branch = '1') then
                    state <= S_BRANCH_SYNC;
                elsif (bool(irqlatch0) and bool(de_en) and (not bool(evt_emuack))) then
                    evt_saveret <= '1';
                    if bool(evt_membusy) then
                        state <= S_EVT_DELAY;
                    else
                        state <= S_EVT;
                    end if;
                elsif (evt_idle = '1') then
                    evt_saveret <= '1';
                    state <= S_IDLE;
                elsif bool(evt_membusy) then
                    state <= S_DELAY;
                end if;
            when S_DELAY =>
                if (trigger_hold = '1') then
                    if bool(evt_membusy) then
                        state <= S_WAIT;
                    elsif (not bool(evt_busy)) then
                        state <= S_HOLD_DELAY;
                    end if;
                elsif (action_branch = '1') then
                    state <= S_BRANCH_DELAY;
                elsif (bool(irqlatch0) and bool(de_en) and (not bool(evt_emuack))) then
                    state <= S_EVT_DELAY;
                    evt_saveret <= '1';
                elsif (evt_idle = '1') then
                    evt_saveret <= '1';
                    state <= S_IDLE;
                end if;
            when S_WAIT =>
                if (evt_data_valid = '1') then
                    state <= S_HOLD_DELAY;
                end if;
            when S_HOLD_DELAY =>
                if (evt_hold = '0') then
                    state <= S_RESUME;
                end if;
            when S_BRANCH_SYNC =>
                if (trigger_hold = '1') then
                    state <= S_HOLD;
                elsif (evt_idle = '1') then
                    state <= S_IDLE;
                elsif (bool(irqlatch0) and (not bool(irqack))) then
                    evt_saveret <= '1';
                    state <= S_EVT;
                elsif (de_en = '1') then
                    state <= S_EXEC;
                end if;
            when S_BRANCH_DELAY =>
                if (trigger_hold = '1') then
                    state <= S_HOLD_DELAY;
                elsif (evt_idle = '1') then
                    state <= S_IDLE;
                elsif (bool(irqlatch0) and (not bool(irqack))) then
                    state <= S_EVT_DELAY;
                    evt_saveret <= '1';
                elsif (de_en = '1') then
                    state <= S_EXEC;
                end if;
            when S_HOLD =>
                if (evt_hold = '0') then
                    state <= S_RESUME;
                end if;
            when S_RESUME =>
                state <= S_EXEC;
            when S_EVT =>
                if (branch = '1') then
                    state <= S_BRANCH_SYNC;
                elsif (not bool(evt_stall)) then
                    if (evt_membusy = '1') then
                        state <= S_IRQ_DELAY;
                    else
                        state <= S_IRQ;
                    end if;
                end if;
            when S_EVT_DELAY =>
                if (branch = '1') then
                    state <= S_BRANCH_DELAY;
                elsif (not bool(evt_stall)) then
                    state <= S_IRQ_DELAY;
                end if;
            when S_IRQ =>
                state <= S_BRANCH_SYNC;
            when S_IRQ_DELAY =>
                state <= S_BRANCH_DELAY;
            when S_IDLE =>
                if (evt_irq = '1') then
                    state <= S_IRQ;
                end if;
            when others =>
                assert False report "End of Simulation" severity Failure;
        end case;
    end if;
end process PYRV32_CPU_STATE_WORKER;


PYRV32_CPU_S2_S4_MEMIO_IMEM_DATA_SELECT: process (s3_execute_mem_addr, s2_s4_memio_was_imem, dmem_rdata, imem_rdata, s3_execute_action_store, action_preload) is
begin
    if ((s3_execute_mem_addr(CONFIG_DATAMEM_OFFSET_BIT) = '0') and (s3_execute_mem_addr(CONFIG_MMR_ADDR_BIT) = '0')) then
        s2_s4_memio_is_imem <= stdl(bool(action_preload) or bool(s3_execute_action_store));
    else
        s2_s4_memio_is_imem <= '0';
    end if;
    if (s2_s4_memio_was_imem = '1') then
        s2_s4_memio_data_mux <= imem_rdata;
    else
        s2_s4_memio_data_mux <= dmem_rdata;
    end if;
end process PYRV32_CPU_S2_S4_MEMIO_IMEM_DATA_SELECT;


PYRV32_CPU_S2_S4_MEMIO_IMEM_DATA_ACCESS_REGISTER: process (clk) is
begin
    if rising_edge(clk) then
        s2_s4_memio_was_imem <= s2_s4_memio_is_imem;
    end if;
end process PYRV32_CPU_S2_S4_MEMIO_IMEM_DATA_ACCESS_REGISTER;


PYRV32_CPU_S2_S4_MEMIO_WORKER: process (clk) is
begin
    if rising_edge(clk) then
        s2_s4_memio_dmem_busy_d <= dmem_busy;
        if (not bool(s2_s4_memio_dmem_busy_d)) then
            s2_s4_memio_mode_d <= s2_s4_memio_act_lmode;
        end if;
        s3_execute_action_load <= action_preload;
    end if;
end process PYRV32_CPU_S2_S4_MEMIO_WORKER;



imem_write <= stdl(bool(s3_execute_action_store) and bool(s2_s4_memio_is_imem));
imem_wdata <= s3_execute_mem_store_data;



imem_read <= stdl(bool(action_preload) and bool(s2_s4_memio_is_imem));
imem_daddr <= s3_execute_mem_addr(ADDR_SZ-1 downto 0);


PYRV32_CPU_S2_S4_MEMIO_ASSIGN: process (s3_execute_mem_addr, s2_s4_memio_mode_d, s2_s4_memio_act_lmode, dmem_rdata, s3_execute_action_store, action_preload, s2_s4_memio_data_mux, s3_execute_mem_store_data) is
    variable m: t_enum_t_lmode_2;
begin
    dmem_we <= s3_execute_action_store;
    dmem_addr <= s3_execute_mem_addr(ADDR_SZ-1 downto 0);
    dmem_wdata <= s3_execute_mem_store_data;
    dmem_re <= action_preload;
    case s2_s4_memio_mode_d is
        when LB =>
            s3_execute_mem_load_data <= unsigned(resize(signed(dmem_rdata(8-1 downto 0)), 32));
        when LH =>
            s3_execute_mem_load_data <= unsigned(resize(signed(dmem_rdata(16-1 downto 0)), 32));
        when LBU =>
            s3_execute_mem_load_data <= resize(dmem_rdata(8-1 downto 0), 32);
        when LHU =>
            s3_execute_mem_load_data <= resize(dmem_rdata(16-1 downto 0), 32);
        when others =>
            s3_execute_mem_load_data <= s2_s4_memio_data_mux;
    end case;
    m := s2_s4_memio_act_lmode;
    case m is
        when LB =>
            dmem_wsize <= to_unsigned(LDST_BYTE, 2);
        when LH =>
            dmem_wsize <= to_unsigned(LDST_WORD, 2);
        when LBU =>
            dmem_wsize <= to_unsigned(LDST_BYTE, 2);
        when LHU =>
            dmem_wsize <= to_unsigned(LDST_WORD, 2);
        when others =>
            dmem_wsize <= to_unsigned(LDST_DWORD, 2);
    end case;
end process PYRV32_CPU_S2_S4_MEMIO_ASSIGN;

-- If we will have a WB event and src is identical dst, trigger
-- these early hazard conditions
PYRV32_CPU_HAZ_SUBSEQUENT_ACCESS: process (action_wreg, reg_s2, reg_s1, regd_d(0), regd_d(1)) is
    variable rd: unsigned(4 downto 0);
begin
    rd := regd_d(0);
    if (bool(action_wreg) and (rd /= 0)) then
        s1_haz <= stdl(rd = reg_s1);
        s2_haz <= stdl(rd = reg_s2);
    else
        s1_haz <= '0';
        s2_haz <= '0';
    end if;
end process PYRV32_CPU_HAZ_SUBSEQUENT_ACCESS;

-- * Hazard 2: access of a register value that should have been
--   loaded from memory in the previous cycle:
--   > Stall pipeline
PYRV32_CPU_HAZ_ACCESS: process (haz_s1bypass, haz_s2bypass, action_preload, evt_membusy) is
begin
    if (bool(action_preload) and (bool(haz_s1bypass) or bool(haz_s2bypass))) then
        haz_access_future <= evt_membusy;
    else
        haz_access_future <= '0';
    end if;
end process PYRV32_CPU_HAZ_ACCESS;

-- Buffer destination register value for delayed writeback
PYRV32_CPU_S3_EXECUTE_REGD_BUFFER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(s3_execute_branch) then
            s3_execute_regd_buf <= resize(expc, 32);
        elsif bool(s3_execute_action_load) then
            s3_execute_regd_buf <= s3_execute_mem_load_data;
        elsif bool(s3_execute_csr_xs) then
            s3_execute_regd_buf <= s3_execute_reg_out;
        else
            s3_execute_regd_buf <= s3_execute_result;
        end if;
    end if;
end process PYRV32_CPU_S3_EXECUTE_REGD_BUFFER;



evt_reti <= stdl(bool(ex_en) and (mode = xRET));

-- Logic to issue a 'preload' action. When a MMR CSR is implemented,
-- CSR command accesses trigger preload events as well
PYRV32_CPU_S3_EXECUTE_PRELOAD_ASSERT: process (ex_en, mode) is
    variable is_csr_mmr: std_logic;
begin
    is_csr_mmr := '0';
    if bool(ex_en) then
        case mode is
            when STORE =>
                s3_execute_action_store <= '1';
                action_preload <= '0';
            when LOAD =>
                s3_execute_action_store <= '0';
                action_preload <= '1';
            when CP_XCH =>
                s3_execute_action_store <= is_csr_mmr;
                action_preload <= is_csr_mmr;
            when CP_SET =>
                s3_execute_action_store <= is_csr_mmr;
                action_preload <= is_csr_mmr;
            when CP_CLR =>
                s3_execute_action_store <= is_csr_mmr;
                action_preload <= is_csr_mmr;
            when others =>
                s3_execute_action_store <= '0';
                action_preload <= '0';
        end case;
    else
        s3_execute_action_store <= '0';
        action_preload <= '0';
    end if;
end process PYRV32_CPU_S3_EXECUTE_PRELOAD_ASSERT;

-- Instruction executing
PYRV32_CPU_S3_EXECUTE_INSN_EXEC: process (clk) is
    variable rwe: std_logic;
begin
    if rising_edge(clk) then
        action_rete <= '0';
        s3_execute_branch <= s3_execute_will_branch;
        s3_execute_csr_xs <= '0';
        s3_execute_s1bypass_d <= haz_s1bypass_delayed;
        s3_execute_s2bypass_d <= haz_s2bypass_delayed;
        s3_execute_reg_we_d <= s3_execute_reg_we;
        if bool(ex_en) then
            rwe := '0';
            if (mode = ALU) then
                rwe := '1';
            elsif (mode = IMMEDIATE) then
                rwe := '1';
            elsif (mode = LOAD) then
                rwe := '1';
            elsif (mode = CP_XCH) then
                rwe := '1';
                s3_execute_csr_xs <= '1';
            elsif (mode = CP_SET) then
                rwe := '1';
                s3_execute_csr_xs <= '1';
            elsif (mode = CP_CLR) then
                rwe := '1';
                s3_execute_csr_xs <= '1';
            elsif (mode = JMP) then
                rwe := '1';
            elsif (mode = RETE) then
                action_rete <= '1';
            end if;
            s3_execute_reg_we <= rwe;
        else
            s3_execute_reg_we <= '0';
        end if;
    end if;
end process PYRV32_CPU_S3_EXECUTE_INSN_EXEC;

-- "Register bypass for access hazards: read following write
PYRV32_CPU_S3_EXECUTE_BYPASS: process (s3_execute_s1bypass, s3_execute_mem_load_data, s3_execute_s2bypass, s3_execute_s2bypass_d, s3_execute_regs1_buf, s3_execute_did_stall, s3_execute_regs2_buf, s3_execute_result, s3_execute_reg_s2, s3_execute_reg_s1, s3_execute_s1bypass_d, rdata_d, s3_execute_did_load) is
begin
    if bool(s3_execute_s1bypass) then
        if bool(s3_execute_did_load) then
            s3_execute_rs1 <= s3_execute_mem_load_data;
        else
            s3_execute_rs1 <= s3_execute_result;
        end if;
    elsif bool(s3_execute_s1bypass_d) then
        s3_execute_rs1 <= rdata_d;
    elsif bool(s3_execute_did_stall) then
        s3_execute_rs1 <= s3_execute_regs1_buf;
    else
        s3_execute_rs1 <= s3_execute_reg_s1;
    end if;
    if bool(s3_execute_s2bypass) then
        if bool(s3_execute_did_load) then
            s3_execute_rs2 <= s3_execute_mem_load_data;
        else
            s3_execute_rs2 <= s3_execute_result;
        end if;
    elsif bool(s3_execute_s2bypass_d) then
        s3_execute_rs2 <= rdata_d;
    elsif bool(s3_execute_did_stall) then
        s3_execute_rs2 <= s3_execute_regs2_buf;
    else
        s3_execute_rs2 <= s3_execute_reg_s2;
    end if;
end process PYRV32_CPU_S3_EXECUTE_BYPASS;

-- Multiplexer logic to select ALU inputs
PYRV32_CPU_S3_EXECUTE_MUX: process (sh, action_branch, s3_execute_action_immediate, s3_execute_mepc, evt_reti, imm, s3_execute_action_srcpc, evt_exception, evt_vector, expc, s3_execute_rs1, s3_execute_rs2, s3_execute_jump_target) is
begin
    if bool(s3_execute_action_srcpc) then
        s3_execute_mux_a <= resize(expc, 32);
    else
        s3_execute_mux_a <= s3_execute_rs1;
    end if;
    if bool(s3_execute_action_immediate) then
        s3_execute_mux_sh <= sh;
        s3_execute_mux_b <= imm;
    else
        s3_execute_mux_sh <= s3_execute_rs2(5-1 downto 0);
        s3_execute_mux_b <= s3_execute_rs2;
    end if;
    if (bool(evt_exception) and (not bool(action_branch))) then
        newpc <= evt_vector;
    elsif bool(evt_reti) then
        newpc <= s3_execute_mepc;
    else
        newpc <= resize(s3_execute_jump_target, 15);
    end if;
end process PYRV32_CPU_S3_EXECUTE_MUX;


PYRV32_CPU_S3_EXECUTE_MEMORY_ACCESS_HANDLE: process (clk) is
begin
    if rising_edge(clk) then
        s3_execute_did_stall <= evt_stall;
        if (not bool(evt_stall)) then
            s3_execute_did_load <= action_preload;
            s3_execute_s1bypass <= haz_s1bypass;
            s3_execute_s2bypass <= haz_s2bypass;
        end if;
    end if;
end process PYRV32_CPU_S3_EXECUTE_MEMORY_ACCESS_HANDLE;


PYRV32_CPU_S3_EXECUTE_BRANCH_COMPARE: process (mode, func, s3_execute_rs1, s3_execute_rs2, ex_en, s3_execute_action_swbrk) is
    variable f: unsigned(2 downto 0);
begin
    if bool(ex_en) then
        evt_idle <= '0';
        evt_brk <= '0';
        case mode is
            when COND_BRANCH =>
                f := func;
                if ((f = FN_BEQ) and (s3_execute_rs1 = s3_execute_rs2)) then
                    s3_execute_will_branch <= '1';
                elsif ((f = FN_BNE) and (s3_execute_rs1 /= s3_execute_rs2)) then
                    s3_execute_will_branch <= '1';
                elsif ((f = FN_BLT) and (signed(s3_execute_rs1) < signed(s3_execute_rs2))) then
                    s3_execute_will_branch <= '1';
                elsif ((f = FN_BLTU) and (s3_execute_rs1 < s3_execute_rs2)) then
                    s3_execute_will_branch <= '1';
                elsif ((f = FN_BGE) and (signed(s3_execute_rs1) >= signed(s3_execute_rs2))) then
                    s3_execute_will_branch <= '1';
                elsif ((f = FN_BGEU) and (s3_execute_rs1 >= s3_execute_rs2)) then
                    s3_execute_will_branch <= '1';
                else
                    s3_execute_will_branch <= '0';
                end if;
            when xRET =>
                s3_execute_will_branch <= '1';
            when JMP =>
                s3_execute_will_branch <= '1';
            when IDLE =>
                s3_execute_will_branch <= '0';
                evt_idle <= '1';
            when SWTRAP =>
                evt_brk <= s3_execute_action_swbrk;
                s3_execute_will_branch <= '0';
            when others =>
                s3_execute_will_branch <= '0';
        end case;
    else
        s3_execute_will_branch <= '0';
        evt_idle <= '0';
        evt_brk <= '0';
    end if;
end process PYRV32_CPU_S3_EXECUTE_BRANCH_COMPARE;


PYRV32_CPU_S3_EXECUTE_INST_ALU_WORKER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(s3_execute_alu_en) then
            case s3_execute_inst_alu_alu_mode is
                when A_NOP =>
                    s3_execute_result <= s3_execute_mux_b;
                when A_ADD =>
                    s3_execute_result <= (s3_execute_mux_a + s3_execute_mux_b);
                when A_SUB =>
                    s3_execute_result <= (s3_execute_mux_a - s3_execute_mux_b);
                when A_SRL =>
                    s3_execute_result <= shift_right(s3_execute_mux_a, to_integer(s3_execute_mux_sh));
                when A_SRA =>
                    s3_execute_result <= unsigned(shift_right(signed(s3_execute_mux_a), to_integer(s3_execute_mux_sh)));
                when A_SLL =>
                    s3_execute_result <= shift_left(s3_execute_mux_a, to_integer(s3_execute_mux_sh));
                when A_SLT =>
                    if (signed(s3_execute_mux_a) < signed(s3_execute_mux_b)) then
                        s3_execute_result <= to_unsigned(1, 32);
                    else
                        s3_execute_result <= to_unsigned(0, 32);
                    end if;
                when A_SLTU =>
                    if (s3_execute_mux_a < s3_execute_mux_b) then
                        s3_execute_result <= to_unsigned(1, 32);
                    else
                        s3_execute_result <= to_unsigned(0, 32);
                    end if;
                when A_XOR =>
                    s3_execute_result <= (s3_execute_mux_a xor s3_execute_mux_b);
                when A_OR =>
                    s3_execute_result <= (s3_execute_mux_a or s3_execute_mux_b);
                when A_AND =>
                    s3_execute_result <= (s3_execute_mux_a and s3_execute_mux_b);
                when others =>
                    null;
            end case;
        end if;
    end if;
end process PYRV32_CPU_S3_EXECUTE_INST_ALU_WORKER;

-- Use CSR mepc instance

s3_execute_mepc <= resize(s3_execute_csrreg_mepc, 15);
s3_execute_csrreg_depc <= resize(expc, 32);


PYRV32_CPU_S3_EXECUTE_INST_CSR_WRITE: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            s3_execute_inst_csr_csrreg_mie <= to_unsigned(0, 32);
            s3_execute_inst_csr_csrreg_mtvec <= to_unsigned(0, 32);
            s3_execute_csrreg_mepc <= to_unsigned(0, 32);
            s3_execute_inst_csr_csrreg_misa <= to_unsigned(68157696, 32);
            s3_execute_inst_csr_csrreg_mcause <= to_unsigned(0, 32);
            s3_execute_inst_csr_csrreg_mstatus <= to_unsigned(0, 32);
            s3_execute_inst_csr_csrreg_dscratch0 <= to_unsigned(0, 32);
        else
            if bool(action_saveret) then
                s3_execute_csrreg_mepc <= resize(expc, 32);
            elsif bool(s3_execute_inst_csr_csr_we) then
                case s3_execute_inst_csr_csr_addr is
                    when "001100000000" =>
                        s3_execute_inst_csr_csrreg_mstatus <= s3_execute_inst_csr_data;
                    when "001100000001" =>
                        s3_execute_inst_csr_csrreg_misa <= s3_execute_inst_csr_data;
                    when "001100000100" =>
                        s3_execute_inst_csr_csrreg_mie <= s3_execute_inst_csr_data;
                    when "001100000101" =>
                        s3_execute_inst_csr_csrreg_mtvec <= s3_execute_inst_csr_data;
                    when "001101000010" =>
                        s3_execute_inst_csr_csrreg_mcause <= s3_execute_inst_csr_data;
                    when "001101000001" =>
                        s3_execute_csrreg_mepc <= s3_execute_inst_csr_data;
                    when "011110100010" =>
                        s3_execute_inst_csr_csrreg_dscratch0 <= s3_execute_inst_csr_data;
                    when others =>
                        assert False report "End of Simulation" severity Failure;
                end case;
            end if;
        end if;
    end if;
end process PYRV32_CPU_S3_EXECUTE_INST_CSR_WRITE;


PYRV32_CPU_S3_EXECUTE_INST_CSR_READ: process (clk) is
begin
    if rising_edge(clk) then
        if (s3_execute_inst_csr_illegal_csr = '1') then
            assert False report "End of Simulation" severity Failure;
        end if;
        if bool(s3_execute_inst_csr_csr_re) then
            s3_execute_reg_out <= s3_execute_inst_csr_reg;
        end if;
        tap_odata <= s3_execute_inst_csr_csrreg_dscratch0;
    end if;
end process PYRV32_CPU_S3_EXECUTE_INST_CSR_READ;


PYRV32_CPU_S3_EXECUTE_INST_CSR_READ_ASSIGN: process (s3_execute_inst_csr_csr_we, s3_execute_inst_csr_csr_addr, s3_execute_csrreg_depc, s3_execute_inst_csr_csrreg_mie, s3_execute_inst_csr_csrreg_mcause, s3_execute_csrreg_mepc, s3_execute_inst_csr_csrreg_misa, s3_execute_inst_csr_csr_re, s3_execute_inst_csr_csrreg_mtvec, s3_execute_inst_csr_csrreg_mstatus, s3_execute_inst_csr_csrreg_dscratch0) is
begin
    s3_execute_inst_csr_illegal_csr <= '0';
    if ((s3_execute_inst_csr_csr_re = '1') or (s3_execute_inst_csr_csr_we = '1')) then
        case s3_execute_inst_csr_csr_addr is
            when "011110100001" =>
                s3_execute_inst_csr_reg <= s3_execute_csrreg_depc;
            when "001100000000" =>
                s3_execute_inst_csr_reg <= s3_execute_inst_csr_csrreg_mstatus;
            when "001100000001" =>
                s3_execute_inst_csr_reg <= s3_execute_inst_csr_csrreg_misa;
            when "001100000100" =>
                s3_execute_inst_csr_reg <= s3_execute_inst_csr_csrreg_mie;
            when "001101000010" =>
                s3_execute_inst_csr_reg <= s3_execute_inst_csr_csrreg_mcause;
            when "001100000101" =>
                s3_execute_inst_csr_reg <= s3_execute_inst_csr_csrreg_mtvec;
            when "001101000001" =>
                s3_execute_inst_csr_reg <= s3_execute_csrreg_mepc;
            when "011110100010" =>
                s3_execute_inst_csr_reg <= s3_execute_inst_csr_csrreg_dscratch0;
            when others =>
                s3_execute_inst_csr_reg <= unsigned'("11011110101011011011111011101111");
                s3_execute_inst_csr_illegal_csr <= '1';
        end case;
    else
        s3_execute_inst_csr_reg <= unsigned'("11011110101011011011111011101111");
    end if;
end process PYRV32_CPU_S3_EXECUTE_INST_CSR_READ_ASSIGN;


PYRV32_CPU_S3_EXECUTE_INST_CSR_WRITE_ASSIGN: process (s3_execute_inst_csr_csr_we, s3_execute_reg_in, mode, tap_idata, s3_execute_inst_csr_reg, action_dbg_wr) is
begin
    if bool(s3_execute_inst_csr_csr_we) then
        if (mode = CP_XCH) then
            s3_execute_inst_csr_data <= s3_execute_reg_in;
        elsif (mode = CP_SET) then
            s3_execute_inst_csr_data <= (s3_execute_reg_in or s3_execute_inst_csr_reg);
        elsif (mode = CP_CLR) then
            s3_execute_inst_csr_data <= (s3_execute_reg_in and (not s3_execute_inst_csr_reg));
        end if;
    elsif bool(action_dbg_wr) then
        s3_execute_inst_csr_data <= tap_idata;
    else
        s3_execute_inst_csr_data <= to_unsigned(0, 32);
    end if;
end process PYRV32_CPU_S3_EXECUTE_INST_CSR_WRITE_ASSIGN;

-- imm contains CSR register address
PYRV32_CPU_S3_EXECUTE_INST_CSR_HANDLE_CSR_OP: process (ex_en, imm, tap_addr, mode, s3_execute_inst_csr_csrreg_mstatus, action_dbg_wr) is
begin
    s3_execute_inst_csr_csr_we <= '0';
    s3_execute_inst_csr_csr_re <= '0';
    action_upie <= s3_execute_inst_csr_csrreg_mstatus(4);
    if bool(ex_en) then
        if bool(action_dbg_wr) then
            s3_execute_inst_csr_csr_addr <= tap_addr;
            s3_execute_inst_csr_csr_we <= '1';
        else
            s3_execute_inst_csr_csr_addr <= resize(imm, 12);
        end if;
        case mode is
            when CP_XCH =>
                s3_execute_inst_csr_csr_we <= '1';
                s3_execute_inst_csr_csr_re <= '1';
            when CP_SET =>
                s3_execute_inst_csr_csr_re <= '1';
                s3_execute_inst_csr_csr_we <= '1';
            when CP_CLR =>
                assert False report "End of Simulation" severity Failure;
            when others =>
                null;
        end case;
    end if;
end process PYRV32_CPU_S3_EXECUTE_INST_CSR_HANDLE_CSR_OP;



s3_execute_indirect <= (s3_execute_mux_a + imm);
s3_execute_jump_target <= (s3_execute_mux_a + imm);



s3_execute_reg_in <= s3_execute_rs1;



s3_execute_mem_addr <= s3_execute_indirect;
s3_execute_mem_store_data <= s3_execute_rs2;

-- Destination register multiplexing
PYRV32_CPU_S3_EXECUTE_REG_DEST_MUX: process (evt_data_valid, s3_execute_mem_load_data, s3_execute_reg_out, action_delay, s3_execute_branch, s3_execute_regd_buf, s3_execute_action_load, expc, s3_execute_csr_xs, s3_execute_result) is
begin
    if bool(action_delay) then
        if bool(evt_data_valid) then
            rdata_d <= s3_execute_mem_load_data;
        else
            rdata_d <= s3_execute_regd_buf;
        end if;
    else
        if bool(s3_execute_branch) then
            rdata_d <= resize(expc, 32);
        elsif bool(s3_execute_action_load) then
            rdata_d <= s3_execute_mem_load_data;
        elsif bool(s3_execute_csr_xs) then
            rdata_d <= s3_execute_reg_out;
        else
            rdata_d <= s3_execute_result;
        end if;
    end if;
end process PYRV32_CPU_S3_EXECUTE_REG_DEST_MUX;


PYRV32_CPU_S3_EXECUTE_REGS_BUFFER: process (clk) is
begin
    if rising_edge(clk) then
        s3_execute_regs1_buf <= s3_execute_reg_s1;
        s3_execute_regs2_buf <= s3_execute_reg_s2;
    end if;
end process PYRV32_CPU_S3_EXECUTE_REGS_BUFFER;


PYRV32_CPU_S3_EXECUTE_ASSIGN: process (s3_execute_will_branch, ex_en, s3_execute_reg_we_d, action_delay, s3_execute_reg_we) is
begin
    s3_execute_alu_en <= ex_en;
    action_branch <= s3_execute_will_branch;
    if (action_delay = '1') then
        action_reg_we <= s3_execute_reg_we_d;
    else
        action_reg_we <= s3_execute_reg_we;
    end if;
end process PYRV32_CPU_S3_EXECUTE_ASSIGN;

-- Common assignments
PYRV32_CPU_COMMON: process (evt_brk, imem_idata, dmem_busy, irqack, evt_dbgbreak, evt_saveret, action_rete, exception_irq, state, branch, action_emuexec, evt_hold, exception_override, tap_emuir, evt_dbg_wr, irqlatch0, evt_emuack, evt_idle, reset, exception_evaddr, lhold, pipe_valid, mode, dmem_ready, evt_stall) is
    variable busy: std_logic;
    variable fetch_enable: std_logic;
    variable is_branch: std_logic;
    variable is_exception: std_logic;
    variable flush: std_logic;
    variable is_stall: std_logic;
    variable execute_enable: std_logic;
begin
    evt_emumask <= '0';
    evt_reset <= reset;
    evt_irq <= exception_irq;
    evt_override <= exception_override;
    evt_vector <= exception_evaddr;
    evt_rete <= action_rete;
    evt_membusy <= dmem_busy;
    evt_data_valid <= dmem_ready;
    flush := stdl((state = S_IDLE) or (state = S_HOLD) or (state = S_HOLD_DELAY) or (state = S_WAIT));
    is_exception := stdl((state = S_EVT) or (state = S_EVT_DELAY));
    evt_exception <= is_exception;
    action_dbg_wr <= evt_dbg_wr;
    action_delay <= stdl((state = S_DELAY) or (state = S_BRANCH_DELAY) or (state = S_HOLD_DELAY) or (state = S_WAIT) or (state = S_EVT_DELAY) or (state = S_IRQ_DELAY));
    trigger_hold <= stdl(bool(evt_hold) or bool(evt_brk));
    dmem_delay <= lhold;
    is_branch := stdl(bool(branch) or bool(is_exception));
    ibranch <= is_branch;
    busy := stdl(pipe_valid((PIPELEN - 1)-1 downto 0) /= 0);
    evt_busy <= busy;
    evt_cpustat <= unsigned'(evt_idle & evt_dbgbreak & irqack & irqlatch0 & evt_brk & evt_saveret & busy & reset);
    pipe_en <= stdl((not bool(evt_emuack)) and (not bool(flush)));
    is_stall := evt_stall;
    pipe_clr <= stdl(bool(evt_idle) or bool(evt_brk));
    fetch_enable := stdl((bool(is_branch) or bool(pipe_valid(0))) and (not bool(is_stall)));
    fe_en <= fetch_enable;
    imem_ire <= fetch_enable;
    de_en <= stdl(bool(pipe_valid(1)) and (not bool(is_stall)));
    execute_enable := pipe_valid(2);
    ex_en <= stdl(bool(execute_enable) and (not bool(is_stall)));
    exception_illegal <= stdl((mode = ILLEGAL) and bool(execute_enable));
    if (mode = STORE) then
        maybe_bypass_s1 <= '0';
    else
        maybe_bypass_s1 <= '1';
    end if;
    if bool(action_emuexec) then
        insn <= tap_emuir;
    else
        insn <= imem_idata;
    end if;
end process PYRV32_CPU_COMMON;

-- Hazard handling:
-- 
-- * Hazard 1: write to reg that's read in the next cycle:
--   > Simply bypass register values
PYRV32_CPU_HAZARD_BYPASS: process (s1_haz, s2_haz, maybe_bypass_s1, ex_en, mode) is
begin
    if ((not bool(ex_en)) or (mode = COND_BRANCH)) then
        haz_s1bypass <= '0';
        haz_s2bypass <= '0';
    else
        if bool(s1_haz) then
            haz_s1bypass <= maybe_bypass_s1;
        else
            haz_s1bypass <= '0';
        end if;
        if bool(s2_haz) then
            haz_s2bypass <= '1';
        else
            haz_s2bypass <= '0';
        end if;
    end if;
end process PYRV32_CPU_HAZARD_BYPASS;

-- Event handling, ZPUng compatible
-- This handles IRQ events, internal exceptions and emulation. It can in this
-- case function independently of an existing CSR unit.
-- Note however, that interrupt nesting must be enabled in software.
PYRV32_CPU_EVTHANDLER: process (clk) is
begin
    if rising_edge(clk) then
        if (evt_reset = '1') then
            irqlatch0 <= '0';
            irqprio <= '0';
            action_saveret <= '0';
            irqack <= '0';
        else
            if (irqlatch0 = '0') then
                irqlatch0 <= evt_irq;
            end if;
            if (irqack = '1') then
                if ((evt_override = '1') and (action_upie = '1')) then
                    irqack <= '0';
                    irqprio <= '1';
                end if;
                if (evt_reti = '1') then
                    if (irqprio = '0') then
                        irqack <= '0';
                    else
                        irqprio <= '0';
                    end if;
                end if;
                irqlatch0 <= '0';
            elsif ((state = S_IRQ) or (state = S_IRQ_DELAY)) then
                irqack <= '1';
            end if;
            action_saveret <= evt_saveret;
        end if;
    end if;
end process PYRV32_CPU_EVTHANDLER;

-- Handles buffering of registers and stall event.
-- We stall when trying to access something that is not yet valid,
-- unless we're branching (which resolves the issue)
PYRV32_CPU_BUFFER: process (clk) is
begin
    if rising_edge(clk) then
        evt_stall <= stdl(bool(haz_access_future) and (not bool(ibranch)));
        if ((state /= S_IDLE) and (not bool(evt_stall))) then
            depc <= curpc;
            expc <= depc;
        end if;
        if bool(de_en) then
            sh <= reg_s2;
        end if;
        if (not bool(evt_stall)) then
            regd_d(1) <= regd_d(0);
            regd_d(0) <= reg_d;
        end if;
        if bool(action_delay) then
            regd_addr <= regd_d(1);
        else
            regd_addr <= regd_d(0);
        end if;
        was_delay(1) <= was_delay(0);
        was_delay(0) <= haz_load_collision;
        was_membusy(1) <= was_membusy(0);
        was_membusy(0) <= evt_membusy;
    end if;
end process PYRV32_CPU_BUFFER;

-- Pipe control
-- We need to handle the cases:
-- * IRQ event:
--   Insert '0' bubble and wait for pipeline to flush
-- * Branch effective:
--   Stall pipeline, not including fetch
-- * Exception:
--         Immediately stall pipeline including fetch, enter
--         exception mode
PYRV32_CPU_PIPECONTROL: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            pipe_valid <= to_unsigned(0, 4);
        elsif (evt_emuexec = '1') then
            pipe_valid <= to_unsigned(2, 4);
        elsif (ibranch = '1') then
            pipe_valid <= to_unsigned(PIPE_RESET_BRANCH, 4);
        elsif (pipe_clr = '1') then
            pipe_valid <= to_unsigned(0, 4);
        else
            pipe_valid <= unsigned'(pipe_valid((PIPELEN - 1)-1 downto 0) & pipe_en);
        end if;
    end if;
end process PYRV32_CPU_PIPECONTROL;


PYRV32_CPU_ASSIGN_DEBUGPC: process (clk) is
begin
    if rising_edge(clk) then
        if (ex_en = '1') then
            tap_curpc <= resize(expc, 32);
        end if;
    end if;
end process PYRV32_CPU_ASSIGN_DEBUGPC;

-- Debug Logic state machine for three pipeline stage CPU types
PYRV32_CPU_MAYBE_DEBUG_FSM: process (clk) is
begin
    if rising_edge(clk) then
        if (tap_reset = '1') then
            maybe_debug_state <= S_RUN;
            maybe_debug_swbreak <= '0';
        else
            case maybe_debug_state is
                when S_RUN =>
                    if ((tap_emureq = '1') or (evt_brk = '1')) then
                        if ((not bool(maybe_debug_emumask)) or bool(evt_brk)) then
                            maybe_debug_state <= S_EMUACK;
                        end if;
                        if bool(evt_brk) then
                            maybe_debug_swbreak <= '1';
                        end if;
                    end if;
                when S_EMUACK =>
                    if (maybe_debug_busy = '0') then
                        maybe_debug_state <= S_EMULATION;
                    end if;
                when S_RESUME =>
                    maybe_debug_state <= S_RUN;
                when S_EMUEXEC =>
                    if bool(evt_rete) then
                        maybe_debug_state <= S_RUN;
                        maybe_debug_swbreak <= '0';
                    elsif (maybe_debug_busy = '0') then
                        maybe_debug_state <= S_EMUACK;
                    end if;
                when others => -- S_EMULATION
                    if (evt_reset = '1') then
                        maybe_debug_swbreak <= '0';
                    end if;
                    if (tap_emuexec = '1') then
                        maybe_debug_state <= S_EMUEXEC;
                    end if;
            end case;
        end if;
    end if;
end process PYRV32_CPU_MAYBE_DEBUG_FSM;


PYRV32_CPU_MAYBE_DEBUG_ASSIGN: process (evt_busy, maybe_debug_state, tap_emumask, evt_cpustat, maybe_debug_swbreak, evt_emumask, tap_emuexec) is
    variable ack: std_logic;
    variable t: std_logic;
    variable emulation_exec: std_logic;
begin
    ack := stdl((maybe_debug_state = S_EMUACK) or (maybe_debug_state = S_EMULATION) or (maybe_debug_state = S_EMUEXEC));
    tap_exstat <= evt_cpustat;
    tap_emuack <= ack;
    evt_emuack <= ack;
    evt_dbgbreak <= maybe_debug_swbreak;
    tap_emurdy <= stdl(maybe_debug_state = S_EMULATION);
    emulation_exec := stdl(bool(tap_emuexec) and (maybe_debug_state = S_EMULATION));
    evt_hold <= stdl(((maybe_debug_state = S_EMULATION) or (maybe_debug_state = S_EMUACK) or (maybe_debug_state = S_RESUME)) and (not bool(tap_emuexec)));
    evt_emuexec <= emulation_exec;
    evt_dbg_wr <= stdl((maybe_debug_state = S_RUN) and bool(tap_emuexec));
    t := stdl(bool(evt_emumask) and bool(tap_emumask));
    maybe_debug_emumask <= t;
    maybe_debug_busy <= stdl(bool(evt_busy) or bool(t));
end process PYRV32_CPU_MAYBE_DEBUG_ASSIGN;



reg_d <= insn(SLICE_RD);
reg_s1 <= insn(SLICE_RS1);
reg_s2 <= insn(SLICE_RS2);


PYRV32_CPU_S2_DECODE_INST_DECODER_IMM_EXTEND: process (s2_decode_inst_decoder_imm_extend_21, insn, s2_decode_inst_decoder_immtype) is
begin
    case s2_decode_inst_decoder_immtype is
        when TYPE_I =>
            s2_decode_pc_imm <= unsigned'(s2_decode_inst_decoder_imm_extend_21 & insn(31-1 downto 20));
        when TYPE_S =>
            s2_decode_pc_imm <= unsigned'(s2_decode_inst_decoder_imm_extend_21 & insn(31-1 downto 25) & insn(12-1 downto 7));
        when TYPE_B =>
            s2_decode_pc_imm <= unsigned'(s2_decode_inst_decoder_imm_extend_21(21-1 downto 1) & insn(7) & insn(31-1 downto 25) & insn(12-1 downto 8) & to_unsigned(0, 1));
        when TYPE_U =>
            s2_decode_pc_imm <= unsigned'(insn(32-1 downto 12) & to_unsigned(0, 12));
        when TYPE_J =>
            s2_decode_pc_imm <= unsigned'(s2_decode_inst_decoder_imm_extend_21(21-1 downto 9) & insn(20-1 downto 12) & insn(20) & insn(31-1 downto 25) & insn(25-1 downto 21) & to_unsigned(0, 1));
        when others =>
            s2_decode_pc_imm <= MYHDL45_UNDEFINED(32);
    end case;
end process PYRV32_CPU_S2_DECODE_INST_DECODER_IMM_EXTEND;


PYRV32_CPU_S2_DECODE_INST_DECODER_WORKER: process (insn) is
    variable func3: unsigned(31 downto 0);
    variable preload: std_logic;
    variable enable_alu: std_logic;
    variable itype: t_enum_t_itype_6;
    variable func12: unsigned(31 downto 0);
    variable m: t_enum_t_mode_3;
    variable aop: t_enum_t_aluop_4;
    variable load_mode: t_enum_t_lmode_2;
    variable op: unsigned(31 downto 0);
begin
    op := resize(insn(OPCODE), 32);
    enable_alu := '0';
    m := NOP;
    aop := A_NOP;
    s2_decode_de_action_immediate <= '0';
    s2_decode_de_action_srcpc <= '0';
    s2_decode_de_action_swbrk <= '0';
    itype := TYPE_NONE;
    func3 := resize(insn(FUNCT3), 32);
    preload := '0';
    load_mode := LW;
    case op is
        when "00000000000000000000000000000011" =>
            itype := TYPE_I;
            aop := A_NOP;
            preload := '1';
            m := LOAD;
            case func3 is
                when "00000000000000000000000000000000" =>
                    load_mode := LB;
                when "00000000000000000000000000000001" =>
                    load_mode := LH;
                when "00000000000000000000000000000010" =>
                    load_mode := LW;
                when "00000000000000000000000000000100" =>
                    load_mode := LBU;
                when "00000000000000000000000000000101" =>
                    load_mode := LHU;
                when others =>
                    m := ILLEGAL;
            end case;
        when "00000000000000000000000000100011" =>
            itype := TYPE_S;
            s2_decode_de_action_immediate <= '1';
            m := STORE;
            aop := A_ADD;
            case func3 is
                when "00000000000000000000000000000000" =>
                    load_mode := LB;
                when "00000000000000000000000000000001" =>
                    load_mode := LH;
                when "00000000000000000000000000000010" =>
                    load_mode := LW;
                when others =>
                    m := ILLEGAL;
            end case;
        when "00000000000000000000000000010111" =>
            itype := TYPE_U;
            m := ALU;
            aop := A_ADD;
            s2_decode_de_action_immediate <= '1';
            s2_decode_de_action_srcpc <= '1';
        when "00000000000000000000000000110111" =>
            itype := TYPE_U;
            s2_decode_de_action_immediate <= '1';
            m := IMMEDIATE;
        when "00000000000000000000000001101111" =>
            m := JMP;
            aop := A_ADD;
            s2_decode_de_action_srcpc <= '1';
            s2_decode_de_action_immediate <= '1';
            itype := TYPE_J;
        when "00000000000000000000000001100111" =>
            m := JMP;
            aop := A_ADD;
            s2_decode_de_action_immediate <= '1';
            itype := TYPE_I;
        when "00000000000000000000000001100011" =>
            m := COND_BRANCH;
            itype := TYPE_B;
            aop := A_ADD;
            s2_decode_de_action_srcpc <= '1';
            s2_decode_de_action_immediate <= '1';
            case func3 is
                when "00000000000000000000000000000000" =>
                    null;
                when "00000000000000000000000000000001" =>
                    null;
                when "00000000000000000000000000000100" =>
                    null;
                when "00000000000000000000000000000101" =>
                    null;
                when "00000000000000000000000000000110" =>
                    null;
                when "00000000000000000000000000000111" =>
                    null;
                when others =>
                    m := ILLEGAL;
            end case;
        when "00000000000000000000000000010011" =>
            itype := TYPE_I;
            m := ALU;
            enable_alu := '1';
            s2_decode_de_action_immediate <= '1';
        when "00000000000000000000000000110011" =>
            itype := TYPE_R;
            m := ALU;
            enable_alu := '1';
        when "00000000000000000000000001110011" =>
            itype := TYPE_I;
            m := CONTROL;
            if (func3 = FN_PRIV) then
                func12 := resize(insn(FUNCT12), 32);
                m := SWTRAP;
                case func12 is
                    when "00000000000000000000000000000001" =>
                        s2_decode_de_action_swbrk <= '1';
                    when "00000000000000000000011110110010" =>
                        m := RETE;
                    when "00000000000000000000001100000010" =>
                        m := xRET;
                    when "00000000000000000000000100000101" =>
                        m := IDLE;
                    when others =>
                        m := ILLEGAL;
                end case;
            elsif (func3 = FN_CSRRW) then
                m := CP_XCH;
            elsif (func3 = FN_CSRRS) then
                m := CP_SET;
            elsif (func3 = FN_CSRRC) then
                m := CP_CLR;
            end if;
        when others =>
            m := ILLEGAL;
    end case;
    if bool(enable_alu) then
        case func3 is
            when "00000000000000000000000000000000" =>
                if (itype = TYPE_I) then
                    aop := A_ADD;
                elsif bool(insn(MOD_ARITH)) then
                    aop := A_SUB;
                else
                    aop := A_ADD;
                end if;
            when "00000000000000000000000000000001" =>
                aop := A_SLL;
            when "00000000000000000000000000000010" =>
                aop := A_SLT;
            when "00000000000000000000000000000011" =>
                aop := A_SLTU;
            when "00000000000000000000000000000100" =>
                aop := A_XOR;
            when "00000000000000000000000000000101" =>
                if bool(insn(MOD_ARITH)) then
                    aop := A_SRA;
                else
                    aop := A_SRL;
                end if;
            when "00000000000000000000000000000110" =>
                aop := A_OR;
            when "00000000000000000000000000000111" =>
                aop := A_AND;
            when others =>
                null;
        end case;
    end if;
    s2_decode_inst_decoder_imm31 <= insn(31);
    s2_decode_inst_decoder_immtype <= itype;
    s2_decode_de_action_lmode <= load_mode;
    if ((itype = TYPE_S) or (itype = TYPE_B)) then
        s2_decode_de_action_wreg <= '0';
    else
        s2_decode_de_action_wreg <= '1';
    end if;
    s2_decode_de_action_aop <= aop;
    s2_decode_pc_mode <= m;
    s2_decode_pc_func <= resize(func3, 6);
    
end process PYRV32_CPU_S2_DECODE_INST_DECODER_WORKER;

-- Standard PyPS instruction decoder
PYRV32_CPU_S2_DECODE_INSN_DECODE: process (clk) is
begin
    if rising_edge(clk) then
        if bool(de_en) then
            mode <= s2_decode_pc_mode;
            func <= resize(s2_decode_pc_func, 3);
            imm <= s2_decode_pc_imm;
            s3_execute_action_swbrk <= s2_decode_de_action_swbrk;
            s3_execute_action_srcpc <= s2_decode_de_action_srcpc;
            s3_execute_inst_alu_alu_mode <= s2_decode_de_action_aop;
            s2_s4_memio_act_lmode <= s2_decode_de_action_lmode;
            s3_execute_action_immediate <= s2_decode_de_action_immediate;
            action_wreg <= s2_decode_de_action_wreg;
        end if;
    end if;
end process PYRV32_CPU_S2_DECODE_INSN_DECODE;



regd_data <= rdata_d;
regd_we <= action_reg_we;



branch <= action_branch;


PYRV32_CPU_S1_FETCH_FORESEE: process (s1_fetch_pc, newpc, ibranch) is
begin
    if (ibranch = '1') then
        s1_fetch_nextpc <= resize(newpc, 32);
    else
        s1_fetch_nextpc <= (s1_fetch_pc + INSTRUCTION_SIZE_BYTES);
    end if;
    imem_iaddr <= resize(s1_fetch_pc(CONFIG_BRAM_ADDR_WIDTH-1 downto PC_ADDRESS_LSB), 20);
    curpc <= resize(s1_fetch_pc, 15);
end process PYRV32_CPU_S1_FETCH_FORESEE;


PYRV32_CPU_S1_FETCH_PROCEED: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            s1_fetch_pc <= to_unsigned(0, 32);
        else
            if bool(fe_en) then
                s1_fetch_pc <= s1_fetch_nextpc;
                
            end if;
        end if;
    end if;
end process PYRV32_CPU_S1_FETCH_PROCEED;

end architecture MyHDL;
