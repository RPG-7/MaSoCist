/* NEO430 simple SoC setup
 *
 * Do not edit this file if it has a .vhdl extension, all changes will be
 * void!
 *
 *
 */

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.busdef.all;
use work.global_config.all;
use work.memory_initialization.all;
use work.ram.all;

library potato;
	use potato.potato_pkg.all;
	use potato.pp_types.all;

#include "../../include/generated/autoconf.h"

entity SoC is
	port (
		clk			 : in  std_ulogic; -- global clock, rising edge
		reset			 : in  std_ulogic; -- global reset, async, LOW-active

#ifdef CONFIG_UART
		uartio_tx       : out    std_logic;
		uartio_rx       : in     std_logic;
		uartio_rxirq    : out    std_logic;
#endif

#ifdef CONFIG_SPI
		spio_cs         : out    std_logic;
		spio_sclk       : out    std_logic;
		spio_mosi       : out    std_logic;
		spio_miso       : in     std_logic;
#endif

		-- Interrupts:
		irq_i			 : in  std_ulogic; -- external interrupt request line
		irq_ack_o  : out std_ulogic  -- external interrupt request acknowledge
	);
end SoC;

architecture potato_top_rtl of SoC is
	constant WORD_SIZE : natural := 32;

	-- Instruction memory signals:
	signal imem_address : std_logic_vector(31 downto 0);
	signal imem_data    : std_logic_vector(31 downto 0);
	-- signal imem_req, imem_ack : std_logic;

	-- Data memory signals:
	signal dmem_address       : std_logic_vector(31 downto 0);
	signal dmem_data_in       : std_logic_vector(31 downto 0);
	signal dmem_data_in_mux   : std_logic_vector(31 downto 0);
	signal dmem_data_out      : std_logic_vector(31 downto 0);
	signal dmem_data_size     : std_logic_vector( 1 downto 0);
	signal dmem_read_req      : std_logic;
	signal dmem_read_ack      : std_logic;
	signal dmem_write_req     : std_ulogic;
	signal dmem_write_ack     : std_ulogic;

	signal l1_data_we         : std_logic;
	signal l1_data_ready      : std_logic;
	signal l1_data_out        : unsigned(31 downto 0);

	-- Peripheral I/O:
	signal perio_read_req      : std_logic;
	signal perio_read_ack      : std_logic;
	signal perio_write_req     : std_logic;
	signal perio_write_ack     : std_logic;
	signal perio_data_in        : std_logic_vector(31 downto 0);

	-- Wishbone signals:
	signal dmem_if_inputs   : wishbone_master_inputs;
	signal dmem_if_outputs : wishbone_master_outputs;

	signal m1_inputs, m2_inputs   : wishbone_master_inputs;
	signal m1_outputs, m2_outputs : wishbone_master_outputs;

	-- Wishbone interfacing:

	signal wb_perio_wr    : wb_WritePort;
	signal wb_perio_rd    : wb_ReadPort;
	signal perio_ce       : std_ulogic;
	signal perio_ce_d     : std_ulogic;

	signal wb_slv_adr : std_logic_vector(31 downto 0);
	signal wb_slv_sel : std_logic_vector(3 downto 0);
	signal wb_slv_dat : std_logic_vector(31 downto 0);


	-- interrupt system --
	signal irq			 : std_ulogic_vector(7 downto 0);
	signal irq_ack	 : std_ulogic_vector(03 downto 0);
	signal xirq_sync : std_ulogic_vector(01 downto 0);

	constant BYTE_BITS     : integer := WORD_SIZE / 16;
	subtype ramaddr16_t is unsigned(CONFIG_BRAM_ADDR_WIDTH-1 downto BYTE_BITS-1);
	subtype ramaddr32_t is unsigned(CONFIG_BRAM_ADDR_WIDTH-1 downto BYTE_BITS);

	-- Program+data+stack BRAM
	subtype LOW_WORD is integer range 15 downto 0;
	subtype HIGH_WORD is integer range 31 downto 16;

	-- Port A
	signal a_we     : std_logic := '0';
	signal a_addr   : ramaddr16_t;
	signal a_write  : unsigned(WORD_SIZE-1 downto 0);
	signal a_read   : unsigned(WORD_SIZE-1 downto 0);
	-- Port B
	signal b_we     : std_logic;
	signal b_addr   : ramaddr16_t;
	signal b_write  : unsigned(WORD_SIZE-1 downto 0);
	signal b_read   : unsigned(WORD_SIZE-1 downto 0);

begin

	potato_cpu_inst: pp_core
	generic map (
		PROCESSOR_ID => CONFIG_TAP_ID
	)
	port map (
		clk => clk,
		reset => reset,
		timer_clk => clk,
		imem_address => imem_address,
		imem_data_in => imem_data,
		imem_req => open,
		imem_ack => '1',
		dmem_address     => dmem_address,
		dmem_data_in     => dmem_data_in_mux,
		dmem_data_out    => dmem_data_out,
		dmem_data_size   => dmem_data_size,
		dmem_read_req    => dmem_read_req,
		dmem_read_ack    => dmem_read_ack,
		dmem_write_req   => dmem_write_req,
		dmem_write_ack   => dmem_write_ack,
		test_context_out => open,
		irq => irq
	);


	dmem_data_in_mux <= perio_data_in
		when perio_ce_d = '1' else
		dmem_data_in;

	-- L1 data is always ready:
	dmem_read_ack <= perio_read_ack when perio_ce_d = '1' else '1';
	dmem_write_ack <= perio_write_ack when perio_ce_d = '1' else '1';
		
	perio_read_req <= dmem_read_req when perio_ce = '1' else '0';
	perio_write_req <= dmem_write_req when perio_ce = '1' else '0';

-- Conversion:
	wb_perio_wr.adr <= unsigned(dmem_if_outputs.adr);
	wb_perio_wr.dat <= unsigned(dmem_if_outputs.dat);
	wb_perio_wr.sel <= unsigned(dmem_if_outputs.sel);
	wb_perio_wr.dat <= unsigned(dmem_if_outputs.dat);
	wb_perio_wr.stb <= dmem_if_outputs.stb;
	wb_perio_wr.cyc <= dmem_if_outputs.cyc;
	wb_perio_wr.we <= dmem_if_outputs.we;

	dmem_if_inputs.dat <= std_logic_vector(wb_perio_rd.dat);
	dmem_if_inputs.ack <= wb_perio_rd.ack;

	dmem_if: entity potato.pp_wb_adapter
		port map (
			clk           => clk,
			reset         => reset,
			mem_address   => dmem_address,
			mem_data_in   => dmem_data_out,
			mem_data_out  => perio_data_in,
			mem_data_size => dmem_data_size,
			mem_read_req  => perio_read_req,
			mem_read_ack  => perio_read_ack,
			mem_write_req => perio_write_req,
			mem_write_ack => perio_write_ack,
			wb_inputs     => dmem_if_inputs,
			wb_outputs    => dmem_if_outputs
		);


----------------------------------------------------------------------------
-- RAM/ROM arena

	a_addr <= unsigned(imem_address(CONFIG_BRAM_ADDR_WIDTH downto BYTE_BITS));
	imem_data <= std_logic_vector(a_read);


rom_l: DPRAM16_init
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-1, -- 32 bit wide, LSB 0 aligned
		INIT_DATA => ram16_init_t(BOOTROM_PROG_INIT(0))
	)
	port map (
		clk       => clk,
		a_we      => a_we,
		a_addr    => a_addr,
		a_write   => a_write(LOW_WORD),
		a_read    => a_read(LOW_WORD),
		--
		b_we      => b_we,
		b_addr    => b_addr,
		b_write   => b_write(LOW_WORD),
		b_read    => b_read(LOW_WORD)
	);

rom_h: DPRAM16_init
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-1, -- 32 bit wide, LSB 0 aligned
		INIT_DATA => ram16_init_t(BOOTROM_PROG_INIT(1))
	)
	port map (
		clk       => clk,
		a_we      => a_we,
		a_addr    => a_addr,
		a_write   => a_write(HIGH_WORD),
		a_read    => a_read(HIGH_WORD),
		--
		b_we      => b_we,
		b_addr    => b_addr,
		b_write   => b_write(HIGH_WORD),
		b_read    => b_read(HIGH_WORD)
	);

data_memory_bank_a:
	entity work.lb_dma_memory
	port map (
		clk => clk,
		lb_we           => l1_data_we,
		lb_size_select  => unsigned(dmem_data_size),
		lb_addr         => unsigned(dmem_address),
		lb_data_in      => unsigned(dmem_data_out),
		lb_data_out     => l1_data_out,

		dma_mode        => "00",
		dma_addr        => (others => '0'),
		dma_datain      => (others => '0'),
		dma_dataout     => open,
		dma_we          => '0'

	);

	l1_data_we <= dmem_write_req and not perio_ce;
	dmem_data_in <= std_logic_vector(l1_data_out);

----------------------------------------------------------------------------
perio:
	entity work.mmr_perio

	port map (
 		bus_in          => wb_perio_wr,
 		bus_out         => wb_perio_rd,
		uartio_tx       => uartio_tx,
		uartio_rx       => uartio_rx,
		uartio_rxirq    => uartio_rxirq,
		spio_cs         => spio_cs,
		spio_sclk       => spio_sclk,
		spio_mosi       => spio_mosi,
		spio_miso       => spio_miso,

		reset           => '0',
		clk             => clk,
		ce              => perio_ce

	);

perio_select_delay:
	process(clk)
	begin
		if rising_edge(clk) then
			perio_ce_d <= perio_ce;
		end if;
	end process;

	perio_ce <= dmem_address(CONFIG_MMR_ADDR_BIT);

	-- sync for external IRQ --
	external_irq_sync: process(clk)
	begin
		if rising_edge(clk) then
			xirq_sync <= xirq_sync(0) & irq_i;
		end if;
	end process external_irq_sync;

	-- interrupt priority assignment --
	irq(0) <= '0';		-- timer match (highest priority)
	irq(1) <= '0';		-- UART Rx available [OR] UART Tx done [OR] SPI RTX done
	irq(2) <= '0';			-- GPIO input pin change
	irq(3) <= xirq_sync(1); -- external interrupt request (lowest priority)

	irq(7 downto 4) <= "0000";

	-- external interrupt acknowledge --
	irq_ack_o <= irq_ack(3); -- the internal irq sources do not require an acknowledge

end potato_top_rtl;
