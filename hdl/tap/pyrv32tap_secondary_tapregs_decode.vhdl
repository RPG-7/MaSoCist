-- File generated by gensoc 22532da
-- (c) 2012-2018, Martin Strubel <hackfin@section5.ch>
-- 
-- Changes to this file will be lost. Edit the source file.
-- 
-- LICENSE: Evaluation license. Not for commercial usage.

-- This VHDL address decoder implementation is generated from
-- /home/strubi/src/jtag/uniemu/tap/core_riscv.xml
-- Stylesheet: iomap v0.2
	
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library work;
use work.riscv.all;



entity decode_secondary_tapregs is
	generic ( DATA_WIDTH : natural := 8 );

	port (
		ce        : in  std_logic;

		ctrl      : out secondary_tapregs_WritePort;
		stat      : in  secondary_tapregs_ReadPort;
		data_in   : in  std_logic_vector(DATA_WIDTH-1 downto 0);
		data_out  : out std_logic_vector(DATA_WIDTH-1 downto 0);
		addr      : in  std_logic_vector(BV_MMR_CFG_secondary_tapregs);
		re        : in  std_logic;
		we        : in  std_logic;
		clk       : in  std_logic
	);
end entity decode_secondary_tapregs;

architecture behaviour of decode_secondary_tapregs is

	constant ADDR_MSB : natural := 7;
	subtype REG_SIZE1B is integer range 7 downto 0;
	subtype REG_SIZE2B is integer range 15 downto 0;
	subtype REG_SIZE3B is integer range 23 downto 0;
	subtype REG_SIZE4B is integer range 31 downto 0;

	-- Default register size:
	subtype reg_size1_t is std_logic_vector(7 downto 0);
	subtype reg_size2_t is std_logic_vector(15 downto 0);
	subtype reg_size3_t is std_logic_vector(23 downto 0);
	subtype reg_size4_t is std_logic_vector(31 downto 0);

	signal uaddr : unsigned(BV_MMR_CFG_secondary_tapregs);
	signal dout  : std_logic_vector(DATA_WIDTH-1 downto 0) := (others => '0');


	--------------------------
	-- Register allocations --
	
	-- Register CSR_REGADDR
	signal reg_csr_regaddr : reg_size4_t;

begin

	uaddr    <= unsigned(addr);
	data_out <= dout;

-- Registermap pyrv32_registers

ioproc_secondary_tapregs:
	process(clk)
		variable paddr : unsigned(ADDR_MSB downto 0);
		constant ZEROPAD   :
		unsigned(ADDR_MSB - uaddr'length downto 0) :=
			(others => '0');
	begin

	if rising_edge(clk) then
		ctrl.select_emudata <= '0';
		ctrl.select_emudata_r <= '0';
		ctrl.select_csr_regdata <= '0';
		ctrl.select_csr_regdata_r <= '0';

		if ce = '1' then
		
			paddr := ZEROPAD & uaddr;
			
			-- WRITE
			if we = '1' then
				case paddr is
				when R_pyrv32_registers_CSR_REGADDR =>
					reg_csr_regaddr <= data_in(REG_SIZE4B);
				when R_pyrv32_registers_EMUDATA =>
					ctrl.emudata <= data_in(REG_SIZE4B);
					ctrl.select_emudata <= '1';
				when R_pyrv32_registers_CSR_REGDATA =>
					ctrl.csr_regdata <= data_in(REG_SIZE4B);
					ctrl.select_csr_regdata <= '1';

				when others =>
					
				end case;
			-- READ
			elsif re = '1' then
				
				case paddr is
				when R_pyrv32_registers_EMUDATA_R =>
					dout(REG_SIZE4B) <= stat.emudata_r;
					ctrl.select_emudata_r <= '1';
				when R_pyrv32_registers_CSR_REGDATA_R =>
					dout(REG_SIZE4B) <= stat.csr_regdata_r;
					ctrl.select_csr_regdata_r <= '1';
				when R_pyrv32_registers_DBG_PC =>
					dout(REG_SIZE4B) <= stat.dbg_pc;
				when R_pyrv32_registers_CSR_REGADDR =>
					dout(REG_SIZE4B) <= reg_csr_regaddr;

				when others =>
					
				end case;
			end if;
		end if;
	end if;
	end process;

	-- Assignments
	ctrl.csr_regaddr <= reg_csr_regaddr;

end behaviour;
