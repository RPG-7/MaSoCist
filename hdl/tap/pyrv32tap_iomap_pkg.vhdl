-- File generated by gensoc 22532da
-- (c) 2012-2018, Martin Strubel <hackfin@section5.ch>
-- 
-- Changes to this file will be lost. Edit the source file.
-- 
-- LICENSE: Evaluation license. Not for commercial usage.
----------------------------------------------------------------------------
-- This VHDL package is generated from
-- /home/strubi/src/jtag/uniemu/tap/core_riscv.xml
-- Stylesheet: vhdlregs v0.1



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Header:
use work.periotypes.all;
package riscv is
	-- HW revision tag. Use in your code to sync with firmware.
	constant HWREV_riscv_MAJOR : natural := 0;
	constant HWREV_riscv_MINOR : natural := 0;
	constant HWREV_riscv_EXT   : string := "";

	subtype  regaddr_t is unsigned(7 downto 0);

	subtype  REG_SIZE1B is integer range 7 downto 0;
	subtype  REG_SIZE2B is integer range 15 downto 0;
	subtype  REG_SIZE3B is integer range 23 downto 0;
	subtype  REG_SIZE4B is integer range 31 downto 0;

	-- Register and bitfield constants:

-------------------------------------------------------------------------
-- Address segment 'MMR'
--         Offset: 

	constant R_MMR_MMR_ADDRESS_SLIC : regaddr8_t := x"00";
-- Secondary address register width
	subtype               BV_MMR_CFG_secondary_tapregs is integer range 2 downto 0;

-------------------------------------------------------------------------
-- Address segment 'riscvemu'
--         Offset: 

	constant R_riscvemu_RISCV_EMUSTAT    : regaddr8_t := x"04";
-- Debugger (CP0) state
	subtype               BV_RISCV_CP0STATE is integer range 15 downto 12;
-- Stopped by break instruction
	constant              B_RISCV_BREAK : natural := 10;
-- Stall signal active
	constant              B_RISCV_STALL : natural := 9;
-- Core in reset state
	constant              B_RISCV_INRESET : natural := 8;

-------------------------------------------------------------------------
-- Address segment 'CSR'
--         Offset: 

-- Debug register. Maps to the TAP EMUDATA (out) register.
	constant R_CSR_SCRATCH0         : regaddr8_t := x"17";
-- The DEPC register. Contains the current PC when entering emulation.
	constant R_CSR_DEPC             : regaddr8_t := x"18";

-------------------------------------------------------------------------
-- Address segment 'REG'
--         Offset: 

-- Zero register (hard wired)
	constant R_REG_ZERO             : regaddr8_t := x"00";
-- Temporary register 0
	constant R_REG_T0               : regaddr8_t := x"05";
-- Temporary register 1
	constant R_REG_T1               : regaddr8_t := x"06";
-- Stack pointer
	constant R_REG_SP               : regaddr8_t := x"02";
-- Frame pointer
	constant R_REG_FP               : regaddr8_t := x"08";
-- Return address
	constant R_REG_RA               : regaddr8_t := x"01";
-- Pseudo register: Program Counter. This corresponds to the GDB mapping.
	constant R_REG_PC               : regaddr8_t := x"25";

-------------------------------------------------------------------------
-- Address segment 'pyrv32_registers'
--         Offset: 

-- Generic emulation data access
	constant R_pyrv32_registers_EMUDATA          : regaddr8_t := x"00";
-- Generic emulation data access
	constant R_pyrv32_registers_EMUDATA_R        : regaddr8_t := x"00";
-- CSR register address to access outside emulation
	constant R_pyrv32_registers_CSR_REGADDR      : regaddr8_t := x"01";
-- CSR register address to access outside emulation
	constant R_pyrv32_registers_CSR_REGDATA      : regaddr8_t := x"01";
-- CSR register shadow for volatile data read
	constant R_pyrv32_registers_CSR_REGDATA_R    : regaddr8_t := x"01";
-- Pseudo register: Program Counter. This corresponds to the GDB mapping.
	constant R_pyrv32_registers_DBG_PC           : regaddr8_t := x"02";


	-- Access records:

	type mmr_tap_ReadPort is record
		--! Exported value for register 'R_MMR_MMR_ADDRESS_SLICES'
		--! Exported value for bit (vector) 'MMR_CFG_secondary_tapregs'
		mmr_cfg_secondary_tapregs : std_logic_vector(BV_MMR_CFG_secondary_tapregs);
	end record;

	type mmr_tap_WritePort is record
		--! Exported value for register 'R_MMR_MMR_ADDRESS_SLICES'
		--! Exported value for bit (vector) 'MMR_CFG_secondary_tapregs'
		mmr_cfg_secondary_tapregs : std_logic_vector(BV_MMR_CFG_secondary_tapregs);
	end record;

	type pyrv32_stat_ReadPort is record
		--! Exported value for register 'R_riscvemu_RISCV_EMUSTAT'
		--! Exported value for bit (vector) 'RISCV_CP0STATE'
		riscv_cp0state : std_logic_vector(BV_RISCV_CP0STATE);
		--! Exported value for bit (vector) 'RISCV_BREAK'
		riscv_break : std_logic;
		--! Exported value for bit (vector) 'RISCV_STALL'
		riscv_stall : std_logic;
		--! Exported value for bit (vector) 'RISCV_INRESET'
		riscv_inreset : std_logic;
	end record;

	type pyrv32_stat_WritePort is record
		--! Exported value for register 'R_riscvemu_RISCV_EMUSTAT'
		--! Exported value for bit (vector) 'RISCV_CP0STATE'
		riscv_cp0state : std_logic_vector(BV_RISCV_CP0STATE);
		--! Exported value for bit (vector) 'RISCV_BREAK'
		riscv_break : std_logic;
		--! Exported value for bit (vector) 'RISCV_STALL'
		riscv_stall : std_logic;
		--! Exported value for bit (vector) 'RISCV_INRESET'
		riscv_inreset : std_logic;
	end record;

	type csr_regs_ReadPort is record
		--! Exported value for register 'R_CSR_SCRATCH0'
		scratch0 : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_CSR_DEPC'
		depc : std_logic_vector(REG_SIZE4B);
	end record;

	type csr_regs_WritePort is record
		--! Exported value for register 'R_CSR_SCRATCH0'
		scratch0 : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_CSR_DEPC'
		depc : std_logic_vector(REG_SIZE4B);
	end record;

	type core_regs_ReadPort is record
		--! Exported value for register 'R_REG_ZERO'
		zero : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_T0'
		t0 : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_T1'
		t1 : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_SP'
		sp : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_FP'
		fp : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_RA'
		ra : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_PC'
		pc : std_logic_vector(REG_SIZE4B);
	end record;

	type core_regs_WritePort is record
		--! Exported value for register 'R_REG_ZERO'
		zero : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_T0'
		t0 : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_T1'
		t1 : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_SP'
		sp : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_FP'
		fp : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_RA'
		ra : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_REG_PC'
		pc : std_logic_vector(REG_SIZE4B);
	end record;

	type secondary_tapregs_ReadPort is record
		--! Exported value for register 'R_pyrv32_registers_EMUDATA_R'
		emudata_r : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_pyrv32_registers_CSR_REGDATA_R'
		csr_regdata_r : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_pyrv32_registers_DBG_PC'
		dbg_pc : std_logic_vector(REG_SIZE4B);
	end record;

	type secondary_tapregs_WritePort is record
		--! Exported value for register 'R_pyrv32_registers_EMUDATA'
		emudata : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_pyrv32_registers_CSR_REGADDR'
		csr_regaddr : std_logic_vector(REG_SIZE4B);
		--! Exported value for register 'R_pyrv32_registers_CSR_REGDATA'
		csr_regdata : std_logic_vector(REG_SIZE4B);
		--! Notify access of Register 'EMUDATA'
		select_emudata : std_logic;
		--! Notify access of Register 'EMUDATA_R'
		select_emudata_r : std_logic;
		--! Notify access of Register 'CSR_REGDATA'
		select_csr_regdata : std_logic;
		--! Notify access of Register 'CSR_REGDATA_R'
		select_csr_regdata_r : std_logic;
	end record;

	-- Register maps that explicitely have hidden="false"


end riscv;

